题意

本题题意：给出 `n` 个 `signed int` 范围内的正整数，用这些数（或其中的一部分）组成一个集合，使得集合中__严格大于__平均值的数字尽可能多，并输出最多的个数。

---

#### 解法

这里就有一种较为简单（但高效）的贪心策略：我们每次选取一个前缀，从所有不同长度的前缀中寻找最优的解法。

我们可以在前一次长度小一的前缀处理之后，使用留下的信息在 $\mathcal O(1)$ 的复杂度内完成下一次统计。

等价人话：我们从长度为 `1` 的前缀开始处理，每次添加下一个，做到 $\mathcal O(n)$ 的复杂度。

前提：数列有序。

---

#### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[1000005];
int main(){
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;++i)scanf("%d",&a[i]);
    sort(a+1,a+n+1);
    int ans=0,nw=0;
    long long sum=0;
    for(int i=1;i<=n;++i){
        sum=sum+a[i];
        while((long long)a[nw]*i<=sum&&nw<i)++nw;
        ans=max(ans,i-nw+1);
    }
    printf("%d\n",ans);
    return 0;
}
```

 代码看完了，接下来看实现的策略：

首先，我们将这些数据读入，由于给出的数据是无序的，且没有拓扑关系（也就是谁前谁后不重要），因此我们将这些数据进行排序。

然后就是算法的核心部分，现在给出证明：

---

#### 算法正确性证明

> 我们已经选择了一个序列 $\mathcal C=\{\mathcal C_1,\mathcal C_2,\mathcal.\mathcal.\mathcal.,\mathcal C_m\}$，其中 $\mathcal C_x\in[1,n]$。
> 之后，我们选择的答案集合即为 $\mathcal S=\{a_{\mathcal C_1},a_{\mathcal C_2},\mathcal.\mathcal.\mathcal.,a_{\mathcal C_m}\}$。
> 我们来找到原集合 $ \mathcal a $ 中第一个未被选取的元素，我们可分为如下 `2` 种情况：

1. > 我们发现这个元素后面没有任何一个元素已被选取，即这个元素加入后会处于末尾。
   >
   > 我们将其加入会使答案加 `1` ，但是可能会因为平均值变大而淘汰掉某些元素。
   >
   > 因此，我们需要考虑是否添加这个元素。

2. > 我们发现这个元素后面存在至少一个元素已被选取，即这个元素被加入后不在末尾。
   >
   > 我们可以再次分为 `2` 种情况：
   >
   > 1. > 这个元素比当前选取的元素平均值小。
   >    >
   >    > 我们将其加入后，会将平均值变小，而不会影响答案，故选取必定更优。
   >
   > 2. > 这个元素比当前选取的元素平均值大。
   >    >
   >    > 我们将其加入后，会将平均值变大，但是由于算数基本原理，新的平均值不会比这个数更大，也就是不会淘汰任何一个元素。
   >    >
   >    > 并且，由于这个数符合要求，答案会增加，故选取必定更优。

> 综上所述，我们只要选取了某个数，那么将这个数前面的所有数都选上一定是最优的。
>
> 故：最优方案（至少最优方案之一）必定是某个前缀。

证毕。

代码中的 `nw` 存储的是最小的能对答案产生贡献的数的下标（排序后），因为不断选取更大元素的过程中，平均值必然单调不降，因此在添加之后无法产生贡献的数（也就是被卡线的）一定在原本贡献区间的开头（如果有）。

因此，每一次循环时不断筛去无法产生贡献的数即可。

最终取所有前缀的答案的最大值为最终答案。

---

#### 时间复杂度证明

外层 `for` 循环的最坏执行次数是 `n` 次。

内层  `while` 循环的终止条件存在 $nw\ge i$，而 `i` 与 `nw` 是单调不降的，故内层 `while` 循环在单次程序中最坏执行次数是 `n` 次。

复杂度瓶颈：`sort`，期望复杂度 $\mathcal O(n\log n)$，最坏复杂度 $\mathcal O(n^2)$ 。

因此，本程序期望复杂度 $\mathcal O(n\log n)$，最坏复杂度 $\mathcal O(n^2)$ 。